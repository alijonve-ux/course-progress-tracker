# -*- coding: utf-8 -*-
"""Untitled15.ipynb

Automatically generated by Colab.

Original file is located at
    https://colab.research.google.com/drive/1X_YXxdjKYKrd8hDLwRhL9LuujnqB6b6I
"""

# ============================================
# COURSE PROGRESS TRACKER ‚Äî Colab App (Gradio)
# ============================================

# 1) Install dependencies (quietly)
!pip -q install gradio==4.44.0 matplotlib pillow

import json, os, math, time
from typing import Tuple, Dict
from dataclasses import dataclass, asdict

import gradio as gr
import matplotlib.pyplot as plt
from matplotlib.patches import Rectangle

# --------- Persistence ---------
SAVE_PATH = "/content/course_progress.json"

@dataclass
class ProgressState:
    total_hours: float = 0.0
    completed_hours: float = 0.0
    updated_at: float = 0.0

    def clamp(self):
        if self.total_hours < 0:
            self.total_hours = 0
        if self.completed_hours < 0:
            self.completed_hours = 0
        if self.total_hours > 0:
            self.completed_hours = min(self.completed_hours, self.total_hours)

def load_state() -> ProgressState:
    if os.path.exists(SAVE_PATH):
        try:
            with open(SAVE_PATH, "r") as f:
                data = json.load(f)
            st = ProgressState(**data)
            st.clamp()
            return st
        except Exception:
            pass
    return ProgressState()

def save_state(st: ProgressState):
    st.updated_at = time.time()
    st.clamp()
    with open(SAVE_PATH, "w") as f:
        json.dump(asdict(st), f, indent=2)

# --------- Battery Drawing ---------
def color_for_pct(pct: float) -> str:
    """
    Green (>60%), Yellow (30‚Äì60%), Red (<30%)
    """
    if pct >= 0.60:
        return "#25D366"  # green
    elif pct >= 0.30:
        return "#FFD166"  # yellow
    else:
        return "#EF476F"  # red

def draw_battery(pct: float):
    """
    Returns a Matplotlib Figure that looks like a battery.
    pct must be in [0,1].
    Visual has 10 internal bars that fill discretely with percentage.
    """
    pct = max(0.0, min(1.0, pct))
    fig = plt.figure(figsize=(4, 6), dpi=120)
    ax = plt.gca()
    ax.set_facecolor("black")
    fig.patch.set_facecolor("black")

    # Battery body
    body_x, body_y, body_w, body_h = 0.1, 0.15, 0.8, 0.75
    # Battery "cap"
    cap_w, cap_h = 0.25, 0.06
    cap_x = 0.5 - cap_w / 2
    cap_y = body_y + body_h

    # Outline
    border = Rectangle((body_x, body_y), body_w, body_h,
                       linewidth=3, edgecolor="white", facecolor="none")
    ax.add_patch(border)

    cap = Rectangle((cap_x, cap_y), cap_w, cap_h,
                    linewidth=3, edgecolor="white", facecolor="none")
    ax.add_patch(cap)

    # Internal 10 bars
    bars = 10
    filled_bars = math.ceil(pct * bars) if pct > 0 else 0
    gap = 0.01
    inner_x = body_x + 0.06
    inner_y = body_y + 0.06
    inner_w = body_w - 0.12
    inner_h = body_h - 0.12
    bar_h = (inner_h - gap * (bars - 1)) / bars

    fill_color = color_for_pct(pct)

    for i in range(bars):
        y = inner_y + i * (bar_h + gap)
        face = fill_color if i < filled_bars else "none"
        edge = fill_color if i < filled_bars else "white"
        rect = Rectangle((inner_x, y), inner_w, bar_h,
                         linewidth=1.8, edgecolor=edge, facecolor=face)
        ax.add_patch(rect)

    # Percentage text
    ax.text(0.5, cap_y + cap_h + 0.05, f"{int(round(pct*100))}%",
            color=fill_color, ha="center", va="center", fontsize=30, fontweight="bold")

    # Clean axes
    ax.set_xlim(0, 1)
    ax.set_ylim(0, 1.05)
    ax.axis("off")
    plt.tight_layout()
    return fig

# --------- Helpers ---------
def pct(state: ProgressState) -> float:
    if state.total_hours <= 0:
        return 0.0
    return max(0.0, min(1.0, state.completed_hours / state.total_hours))

def fmt_summary(state: ProgressState) -> str:
    if state.total_hours <= 0:
        return "Set your total course hours to begin."
    return (
        f"**Course Hours:** {state.total_hours:.2f}h\n\n"
        f"**Completed:** {state.completed_hours:.2f}h "
        f"({pct(state)*100:.1f}%)\n\n"
        f"**Remaining:** {max(0.0, state.total_hours - state.completed_hours):.2f}h"
    )

# --------- App Actions ---------
def init_app(state_dict: Dict) -> Tuple[Dict, str, "matplotlib.figure.Figure"]:
    st = load_state()
    state_dict.update(asdict(st))
    figure = draw_battery(pct(st))
    return state_dict, fmt_summary(st), figure

def set_total(state_dict: Dict, total_hours: float) -> Tuple[Dict, str, "matplotlib.figure.Figure", str]:
    st = ProgressState(**state_dict)
    if total_hours is None or total_hours <= 0:
        return state_dict, fmt_summary(st), draw_battery(pct(st)), "Please enter a valid total (> 0)."
    st.total_hours = float(total_hours)
    st.clamp()
    save_state(st)
    state_dict.update(asdict(st))
    return state_dict, fmt_summary(st), draw_battery(pct(st)), "Total course hours updated ‚úîÔ∏è"

def add_completed(state_dict: Dict, add_hours: float) -> Tuple[Dict, str, "matplotlib.figure.Figure", str]:
    st = ProgressState(**state_dict)
    if st.total_hours <= 0:
        return state_dict, fmt_summary(st), draw_battery(pct(st)), "Set total hours first."
    if add_hours is None or add_hours <= 0:
        return state_dict, fmt_summary(st), draw_battery(pct(st)), "Enter a positive number of hours."
    st.completed_hours += float(add_hours)
    st.clamp()
    save_state(st)
    state_dict.update(asdict(st))
    return state_dict, fmt_summary(st), draw_battery(pct(st)), f"Logged +{add_hours:.2f}h ‚è±Ô∏è"

def set_completed_exact(state_dict: Dict, exact_hours: float) -> Tuple[Dict, str, "matplotlib.figure.Figure", str]:
    st = ProgressState(**state_dict)
    if st.total_hours <= 0:
        return state_dict, fmt_summary(st), draw_battery(pct(st)), "Set total hours first."
    if exact_hours is None or exact_hours < 0:
        return state_dict, fmt_summary(st), draw_battery(pct(st)), "Enter a valid number (‚â• 0)."
    st.completed_hours = float(exact_hours)
    st.clamp()
    save_state(st)
    state_dict.update(asdict(st))
    return state_dict, fmt_summary(st), draw_battery(pct(st)), "Completion set ‚úîÔ∏è"

def reset_all(state_dict: Dict) -> Tuple[Dict, str, "matplotlib.figure.Figure", str]:
    st = ProgressState()
    save_state(st)
    state_dict.update(asdict(st))
    return state_dict, fmt_summary(st), draw_battery(0.0), "Reset complete."

# --------- UI ---------
with gr.Blocks(css="""
#title {font-size: 28px; font-weight: 800; margin-bottom: 4px;}
.subtle {opacity: .85}
.stat {font-size: 16px;}
""") as demo:
    gr.Markdown("<div id='title'>üìö COURSE PROGRESS TRACKER</div><div class='subtle'>Battery fills as you study. Data saves automatically.</div>")

    # Invisible state holder
    state = gr.State(asdict(load_state()))

    with gr.Row():
        with gr.Column(scale=1):
            gr.Markdown("### 1) Set / Update Total Course Hours")
            total_in = gr.Number(value=None, label="Total course hours (e.g., 167)", precision=2)
            btn_total = gr.Button("Set Total Hours", variant="primary")
            msg_total = gr.Markdown("", elem_classes=["stat"])

            gr.Markdown("### 2) Log Study Time")
            add_in = gr.Number(value=None, label="Add hours (e.g., 1.5)", precision=2)
            btn_add = gr.Button("Log Hours ‚ñ∂Ô∏è")
            msg_add = gr.Markdown("", elem_classes=["stat"])

            gr.Markdown("**Or set completed exactly**")
            exact_in = gr.Number(value=None, label="Set completed to (hours)", precision=2)
            btn_exact = gr.Button("Set Completed")
            msg_exact = gr.Markdown("", elem_classes=["stat"])

            btn_reset = gr.Button("Reset", variant="secondary")

        with gr.Column(scale=1):
            summary = gr.Markdown("Loading‚Ä¶", elem_classes=["stat"])
            battery_plot = gr.Plot(label="Progress Battery")

    # Wire actions
    demo.load(fn=init_app, inputs=[state], outputs=[state, summary, battery_plot])
    btn_total.click(fn=set_total, inputs=[state, total_in],
                    outputs=[state, summary, battery_plot, msg_total])
    btn_add.click(fn=add_completed, inputs=[state, add_in],
                  outputs=[state, summary, battery_plot, msg_add])
    btn_exact.click(fn=set_completed_exact, inputs=[state, exact_in],
                    outputs=[state, summary, battery_plot, msg_exact])
    btn_reset.click(fn=reset_all, inputs=[state],
                    outputs=[state, summary, battery_plot, msg_add])

demo.launch(share=True)

!pip install matplotlib

# ============================================
# COURSE PROGRESS TRACKER ‚Äî Colab App (Gradio)
# ============================================

# 1) Install dependencies (quietly)
!pip -q install gradio==4.44.0 matplotlib pillow

import json, os, math, time
from typing import Tuple, Dict
from dataclasses import dataclass, asdict

import gradio as gr
import matplotlib.pyplot as plt
from matplotlib.patches import Rectangle
import matplotlib.figure # Import matplotlib.figure directly

# --------- Persistence ---------
SAVE_PATH = "/content/course_progress.json"

@dataclass
class ProgressState:
    total_hours: float = 0.0
    completed_hours: float = 0.0
    updated_at: float = 0.0

    def clamp(self):
        if self.total_hours < 0:
            self.total_hours = 0
        if self.completed_hours < 0:
            self.completed_hours = 0
        if self.total_hours > 0:
            self.completed_hours = min(self.completed_hours, self.total_hours)

def load_state() -> ProgressState:
    if os.path.exists(SAVE_PATH):
        try:
            with open(SAVE_PATH, "r") as f:
                data = json.load(f)
            st = ProgressState(**data)
            st.clamp()
            return st
        except Exception:
            pass
    return ProgressState()

def save_state(st: ProgressState):
    st.updated_at = time.time()
    st.clamp()
    with open(SAVE_PATH, "w") as f:
        json.dump(asdict(st), f, indent=2)

# --------- Battery Drawing ---------
def color_for_pct(pct: float) -> str:
    """
    Green (>60%), Yellow (30‚Äì60%), Red (<30%)
    """
    if pct >= 0.60:
        return "#25D366"  # green
    elif pct >= 0.30:
        return "#FFD166"  # yellow
    else:
        return "#EF476F"  # red

def draw_battery(pct: float):
    """
    Returns a Matplotlib Figure that looks like a battery.
    pct must be in [0,1].
    Visual has 10 internal bars that fill discretely with percentage.
    """
    pct = max(0.0, min(1.0, pct))
    fig = plt.figure(figsize=(4, 6), dpi=120)
    ax = plt.gca()
    ax.set_facecolor("black")
    fig.patch.set_facecolor("black")

    # Battery body
    body_x, body_y, body_w, body_h = 0.1, 0.15, 0.8, 0.75
    # Battery "cap"
    cap_w, cap_h = 0.25, 0.06
    cap_x = 0.5 - cap_w / 2
    cap_y = body_y + body_h

    # Outline
    border = Rectangle((body_x, body_y), body_w, body_h,
                       linewidth=3, edgecolor="white", facecolor="none")
    ax.add_patch(border)

    cap = Rectangle((cap_x, cap_y), cap_w, cap_h,
                    linewidth=3, edgecolor="white", facecolor="none")
    ax.add_patch(cap)

    # Internal 10 bars
    bars = 10
    filled_bars = math.ceil(pct * bars) if pct > 0 else 0
    gap = 0.01
    inner_x = body_x + 0.06
    inner_y = body_y + 0.06
    inner_w = body_w - 0.12
    inner_h = body_h - 0.12
    bar_h = (inner_h - gap * (bars - 1)) / bars

    fill_color = color_for_pct(pct)

    for i in range(bars):
        y = inner_y + i * (bar_h + gap)
        face = fill_color if i < filled_bars else "none"
        edge = fill_color if i < filled_bars else "white"
        rect = Rectangle((inner_x, y), inner_w, bar_h,
                         linewidth=1.8, edgecolor=edge, facecolor=face)
        ax.add_patch(rect)

    # Percentage text
    ax.text(0.5, cap_y + cap_h + 0.05, f"{int(round(pct*100))}%",
            color=fill_color, ha="center", va="center", fontsize=30, fontweight="bold")

    # Clean axes
    ax.set_xlim(0, 1)
    ax.set_ylim(0, 1.05)
    ax.axis("off")
    plt.tight_layout()
    return fig

# --------- Helpers ---------
def pct(state: ProgressState) -> float:
    if state.total_hours <= 0:
        return 0.0
    return max(0.0, min(1.0, state.completed_hours / state.total_hours))

def fmt_summary(state: ProgressState) -> str:
    if state.total_hours <= 0:
        return "Set your total course hours to begin."
    return (
        f"**Course Hours:** {state.total_hours:.2f}h\n\n"
        f"**Completed:** {state.completed_hours:.2f}h "
        f"({pct(state)*100:.1f}%)\n\n"
        f"**Remaining:** {max(0.0, state.total_hours - state.completed_hours):.2f}h"
    )

# --------- App Actions ---------
def init_app(state_dict: Dict) -> Tuple[Dict, str, "matplotlib.figure.Figure"]:
    st = load_state()
    state_dict.update(asdict(st))
    figure = draw_battery(pct(st))
    return state_dict, fmt_summary(st), figure

def set_total(state_dict: Dict, total_hours: float) -> Tuple[Dict, str, "matplotlib.figure.Figure", str]:
    st = ProgressState(**state_dict)
    if total_hours is None or total_hours <= 0:
        return state_dict, fmt_summary(st), draw_battery(pct(st)), "Please enter a valid total (> 0)."
    st.total_hours = float(total_hours)
    st.clamp()
    save_state(st)
    state_dict.update(asdict(st))
    return state_dict, fmt_summary(st), draw_battery(pct(st)), "Total course hours updated ‚úîÔ∏è"

def add_completed(state_dict: Dict, add_hours: float) -> Tuple[Dict, str, "matplotlib.figure.Figure", str]:
    st = ProgressState(**state_dict)
    if st.total_hours <= 0:
        return state_dict, fmt_summary(st), draw_battery(pct(st)), "Set total hours first."
    if add_hours is None or add_hours <= 0:
        return state_dict, fmt_summary(st), draw_battery(pct(st)), "Enter a positive number of hours."
    st.completed_hours += float(add_hours)
    st.clamp()
    save_state(st)
    state_dict.update(asdict(st))
    return state_dict, fmt_summary(st), draw_battery(pct(st)), f"Logged +{add_hours:.2f}h ‚è±Ô∏è"

def set_completed_exact(state_dict: Dict, exact_hours: float) -> Tuple[Dict, str, "matplotlib.figure.Figure", str]:
    st = ProgressState(**state_dict)
    if st.total_hours <= 0:
        return state_dict, fmt_summary(st), draw_battery(pct(st)), "Set total hours first."
    if exact_hours is None or exact_hours < 0:
        return state_dict, fmt_summary(st), draw_battery(pct(st)), "Enter a valid number (‚â• 0)."
    st.completed_hours = float(exact_hours)
    st.clamp()
    save_state(st)
    state_dict.update(asdict(st))
    return state_dict, fmt_summary(st), draw_battery(pct(st)), "Completion set ‚úîÔ∏è"

def reset_all(state_dict: Dict) -> Tuple[Dict, str, "matplotlib.figure.Figure", str]:
    st = ProgressState()
    save_state(st)
    state_dict.update(asdict(st))
    return state_dict, fmt_summary(st), draw_battery(0.0), "Reset complete."

# --------- UI ---------
with gr.Blocks(css="""
#title {font-size: 28px; font-weight: 800; margin-bottom: 4px;}
.subtle {opacity: .85}
.stat {font-size: 16px;}
""") as demo:
    gr.Markdown("<div id='title'>üìö COURSE PROGRESS TRACKER</div><div class='subtle'>Battery fills as you study. Data saves automatically.</div>")

    # Invisible state holder
    state = gr.State(asdict(load_state()))

    with gr.Row():
        with gr.Column(scale=1):
            gr.Markdown("### 1) Set / Update Total Course Hours")
            total_in = gr.Number(value=None, label="Total course hours (e.g., 167)", precision=2)
            btn_total = gr.Button("Set Total Hours", variant="primary")
            msg_total = gr.Markdown("", elem_classes=["stat"])

            gr.Markdown("### 2) Log Study Time")
            add_in = gr.Number(value=None, label="Add hours (e.g., 1.5)", precision=2)
            btn_add = gr.Button("Log Hours ‚ñ∂Ô∏è")
            msg_add = gr.Markdown("", elem_classes=["stat"])

            gr.Markdown("**Or set completed exactly**")
            exact_in = gr.Number(value=None, label="Set completed to (hours)", precision=2)
            btn_exact = gr.Button("Set Completed")
            msg_exact = gr.Markdown("", elem_classes=["stat"])

            btn_reset = gr.Button("Reset", variant="secondary")

        with gr.Column(scale=1):
            summary = gr.Markdown("Loading‚Ä¶", elem_classes=["stat"])
            battery_plot = gr.Plot(label="Progress Battery")

    # Wire actions
    demo.load(fn=init_app, inputs=[state], outputs=[state, summary, battery_plot])
    btn_total.click(fn=set_total, inputs=[state, total_in],
                    outputs=[state, summary, battery_plot, msg_total])
    btn_add.click(fn=add_completed, inputs=[state, add_in],
                  outputs=[state, summary, battery_plot, msg_add])
    btn_exact.click(fn=set_completed_exact, inputs=[state, exact_in],
                    outputs=[state, summary, battery_plot, msg_exact])
    btn_reset.click(fn=reset_all, inputs=[state],
                    outputs=[state, summary, battery_plot, msg_add])

demo.launch()

